<!DOCTYPE html><html lang="en"><head><title>src/Data</title></head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0"><meta name="groc-relative-root" content="../"><meta name="groc-document-path" content="src/Data"><meta name="groc-project-path" content="src/Data.js"><link rel="stylesheet" type="text/css" media="all" href="../assets/style.css"><script type="text/javascript" src="../assets/behavior.js"></script><body><div id="meta"><div class="file-path">src/Data.js</div></div><div id="document"><div class="segment"><div class="comments "><div class="wrapper"><p>Copyright 2020 Ulrich Gaal</p>
<p>Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
you may not use this file except in compliance with the License.
You may obtain a copy of the License at</p>
<pre><code>http://www.apache.org/licenses/LICENSE-2.0</code></pre>
<p>Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.</p></div></div><div class="code"><div class="wrapper"><span class="hljs-keyword">import</span> React, {
  useContext,
  useCallback,
  useMemo,
  useRef,
  useLayoutEffect,
  useState,
  useEffect
} <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>
<span class="hljs-keyword">import</span> Section <span class="hljs-keyword">from</span> <span class="hljs-string">'./Section'</span>
<span class="hljs-keyword">import</span> VScroller <span class="hljs-keyword">from</span> <span class="hljs-string">'./VScroller'</span>
<span class="hljs-keyword">import</span> {
  TableStateType,
  ScrollerStateType,
  ResizerStateType,
  Modes
} <span class="hljs-keyword">from</span> <span class="hljs-string">'./prop-types'</span>
<span class="hljs-keyword">import</span> { ConfigContext } <span class="hljs-keyword">from</span> <span class="hljs-string">'./Table'</span>
<span class="hljs-keyword">import</span> { TableDispatch, CELL_RANGE, COLUMN_RESIZING } <span class="hljs-keyword">from</span> <span class="hljs-string">'./actions'</span>
<span class="hljs-keyword">import</span> { measureCols, log } <span class="hljs-keyword">from</span> <span class="hljs-string">'./utils'</span>
<span class="hljs-keyword">import</span> isEqual <span class="hljs-keyword">from</span> <span class="hljs-string">'lodash.isequal'</span>
<span class="hljs-keyword">import</span> useResizeObserver <span class="hljs-keyword">from</span> <span class="hljs-string">'./hooks/useResizeObserver'</span>
<span class="hljs-keyword">import</span> {
  ScrollerDispatch,
  INVALIDATE,
  VWHEEL
} <span class="hljs-keyword">from</span> <span class="hljs-string">'./reducers/scrollerReducer'</span>
<span class="hljs-keyword">import</span> ResizeBar <span class="hljs-keyword">from</span> <span class="hljs-string">'./ResizeBar'</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">'./Data.css'</span>

const Data = props =&gt; {
  log(<span class="hljs-string">'Data'</span>, 0, props)
  const { state, scrollerState, resizerState } = props
  const { data, columns, cellRange } = state

  const dispatch = useContext(TableDispatch)
  const { rowIdAttr, context } = useContext(ConfigContext)
  const scrollerDispatch = useContext(ScrollerDispatch)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>To keep head and body columns align when body Y scroller appears.</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">const</span> [overflow, setOverflow] = useState(<span class="hljs-literal">false</span>)
  <span class="hljs-keyword">const</span> ref = useRef(<span class="hljs-literal">null</span>)
  useLayoutEffect(() =&gt; {
    <span class="hljs-keyword">const</span> node = ref.current.querySelector(<span class="hljs-string">'.rrt-tbody'</span>)
    setOverflow(node.scrollHeight &gt; node.clientHeight)
  })</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Split columns into two sets (fixed and horizontally scrollable)
Determine if there are any filters
Compute the column order</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">const</span> {
    fixedCols,
    cols,
    hasFilters,
    colOrder,
    hasAutoresizeCols
  } = useMemo(() =&gt; {
    <span class="hljs-keyword">const</span> visibleCols = columns.filter(col =&gt; col.visible !== <span class="hljs-literal">false</span>)
    <span class="hljs-keyword">const</span> { ids, ...rest } = visibleCols.reduce(
      (acc, col) =&gt; {
        <span class="hljs-keyword">const</span> { id, fixed, autoresize, Filter } = col
        <span class="hljs-keyword">const</span> { fixedCols, cols, ids } = acc
        ids.push(id)
        <span class="hljs-keyword">if</span> (fixed) {
          <span class="hljs-keyword">if</span> (cols.length) {
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(
              <span class="hljs-string">`fixed column <span class="hljs-subst">${id}</span> must be declared before non-fixed columns`</span>
            )
          }
          fixedCols.push(col)
        } <span class="hljs-keyword">else</span> {
          cols.push(col)
        }
        <span class="hljs-keyword">if</span> (Filter) {
          acc.hasFilters = <span class="hljs-literal">true</span>
        }
        <span class="hljs-keyword">if</span> (autoresize) {
          acc.hasAutoresizeCols = <span class="hljs-literal">true</span>
        }
        <span class="hljs-keyword">return</span> acc
      },
      {
        fixedCols: [],
        cols: [],
        hasFilters: <span class="hljs-literal">false</span>,
        ids: [],
        hasAutoresizeCols: <span class="hljs-literal">false</span>
      }
    )
    <span class="hljs-keyword">return</span> { colOrder: ids.join(<span class="hljs-string">','</span>), ...rest }
  }, [columns])</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If there are fixed columns, the table uses two
sections and a vertical scroller to scroll them in parallel
Otherwise, there is just one section</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">const</span> { hasFixedCols, fixedRange, range } = useMemo(() =&gt; {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If there are fixed columns, split the cell range if necessary</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">const</span> hasFixedCols = fixedCols.length &gt; <span class="hljs-number">0</span>
    <span class="hljs-keyword">let</span> range = <span class="hljs-literal">null</span>
    <span class="hljs-keyword">let</span> fixedRange = <span class="hljs-literal">null</span>
    <span class="hljs-keyword">if</span> (cellRange) {
      <span class="hljs-keyword">if</span> (hasFixedCols) {
        <span class="hljs-keyword">const</span> xmid = fixedCols.length
        <span class="hljs-keyword">const</span> { col: x } = cellRange
        <span class="hljs-keyword">const</span> xmax = x + cellRange.width
        <span class="hljs-keyword">if</span> (xmax &lt;= xmid) {
          fixedRange = { ...cellRange, split: <span class="hljs-literal">false</span> }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x &gt;= xmid) {
          range = { ...cellRange, col: x - xmid, split: <span class="hljs-literal">false</span> }
        } <span class="hljs-keyword">else</span> {
          fixedRange = { ...cellRange, width: xmid - x, split: <span class="hljs-literal">true</span> }
          range = {
            ...cellRange,
            col: <span class="hljs-number">0</span>,
            width: xmax - xmid,
            split: <span class="hljs-literal">true</span>
          }
        }
      } <span class="hljs-keyword">else</span> {
        range = { ...cellRange, mode: Modes.stretch }
      }
    }
    <span class="hljs-keyword">return</span> { hasFixedCols, range, fixedRange }
  }, [fixedCols, cellRange])</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Manage range selection by handling mouseDown bubbling on table cells</p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">const</span> handleRange = useCallback(
    event =&gt; {
      <span class="hljs-keyword">if</span> (cellRange) {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Process events only if there is a call range</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">const</span> getPosition = event =&gt; {
          <span class="hljs-keyword">const</span> cellElement = event.target.closest(<span class="hljs-string">'.rrt-td'</span>)
          <span class="hljs-keyword">if</span> (!cellElement) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>
          }
          <span class="hljs-keyword">const</span> rowElement = cellElement.parentNode
          <span class="hljs-keyword">const</span> rowsElement = rowElement.parentNode
          <span class="hljs-keyword">const</span> section = rowElement.closest(<span class="hljs-string">'.rrt-section-scrollable'</span>)
          <span class="hljs-keyword">const</span> xmid = fixedCols.length
          <span class="hljs-keyword">const</span> dx = rowIdAttr ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>
          <span class="hljs-keyword">const</span> row = <span class="hljs-built_in">Array</span>.prototype.indexOf.call(
            rowsElement.childNodes,
            rowElement
          )
          <span class="hljs-keyword">const</span> col = <span class="hljs-built_in">Array</span>.prototype.indexOf.call(
            rowElement.childNodes,
            cellElement
          )
          <span class="hljs-keyword">return</span> {
            row,
            col: section ? xmid + col : col - dx
          }
        }
        <span class="hljs-keyword">const</span> createRange = (pos1, pos2) =&gt; {
          <span class="hljs-keyword">const</span> col = <span class="hljs-built_in">Math</span>.min(pos1.col, pos2.col)
          <span class="hljs-keyword">const</span> row = <span class="hljs-built_in">Math</span>.min(pos1.row, pos2.row)
          <span class="hljs-keyword">return</span> {
            col,
            row,
            width: <span class="hljs-built_in">Math</span>.max(pos1.col, pos2.col) - col + <span class="hljs-number">1</span>,
            height: <span class="hljs-built_in">Math</span>.max(pos1.row, pos2.row) - row + <span class="hljs-number">1</span>
          }
        }
        <span class="hljs-keyword">const</span> pos1 = getPosition(event)
        <span class="hljs-keyword">if</span> (pos1) {
          event.stopPropagation()
          event.preventDefault()</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Process events only if a cell has been clicked</p></div></div><div class="code"><div class="wrapper">          <span class="hljs-keyword">const</span> range1 = { ...pos1, width: <span class="hljs-number">1</span>, height: <span class="hljs-number">1</span> }
          <span class="hljs-keyword">if</span> (!isEqual(range1, cellRange)) {
            dispatch({
              type: CELL_RANGE,
              cellRange: range1
            })
          }
          <span class="hljs-keyword">const</span> handlers = {
            handleMouseMove: event =&gt; {
              event.stopPropagation()
              event.preventDefault()
              <span class="hljs-keyword">const</span> pos2 = getPosition(event)
              <span class="hljs-keyword">if</span> (pos2 &amp;&amp; !isEqual(pos1, pos2)) {
                <span class="hljs-keyword">const</span> range2 = createRange(pos1, pos2)
                <span class="hljs-keyword">if</span> (!isEqual(range1, range2)) {
                  dispatch({
                    type: CELL_RANGE,
                    cellRange: range2
                  })
                }
              }
            },
            handleMouseUp: event =&gt; {
              event.stopPropagation()
              event.preventDefault()
              <span class="hljs-built_in">window</span>.removeEventListener(
                <span class="hljs-string">'mousemove'</span>,
                handlers.handleMouseMove,
                <span class="hljs-literal">true</span>
              )
              <span class="hljs-built_in">window</span>.removeEventListener(
                <span class="hljs-string">'mouseup'</span>,
                handlers.handleMouseUp,
                <span class="hljs-literal">true</span>
              )
            }
          }</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Position mouse handlers to create a modal drag loop</p></div></div><div class="code"><div class="wrapper">          <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'mousemove'</span>, handlers.handleMouseMove, <span class="hljs-literal">true</span>)
          <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'mouseup'</span>, handlers.handleMouseUp, <span class="hljs-literal">true</span>)
        }
      }
    },
    [cellRange, fixedCols, rowIdAttr]
  )

  <span class="hljs-keyword">const</span> handleWheel = useCallback(
    event =&gt; {
      <span class="hljs-keyword">if</span> (hasFixedCols) {
        event.stopPropagation()</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Cannot prevent default due to react not supporting passive events yet
event.preventDefault()</p></div></div><div class="code"><div class="wrapper">        <span class="hljs-keyword">const</span> { deltaY } = event
        scrollerDispatch({ type: VWHEEL, deltaY: <span class="hljs-built_in">Math</span>.sign(deltaY) * <span class="hljs-number">30</span> })
      }
    },
    [hasFixedCols, scrollerDispatch]
  )

  useEffect(() =&gt; {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>When data changes, perform column autoresize computations</p></div></div><div class="code"><div class="wrapper">    <span class="hljs-keyword">const</span> { current } = ref
    <span class="hljs-keyword">if</span> (current &amp;&amp; hasAutoresizeCols &amp;&amp; data.length &gt; <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">const</span> section = current.firstChild
      <span class="hljs-keyword">const</span> metrics =
        fixedCols.length &gt; <span class="hljs-number">0</span>
          ? [
              ...measureCols(context, fixedCols, section, rowIdAttr),
              ...measureCols(context, cols, section.nextSibling, <span class="hljs-string">''</span>)
            ]
          : measureCols(context, cols, section, rowIdAttr)
      metrics.forEach(metric =&gt; {
        <span class="hljs-keyword">const</span> {
          column: { id, width }
        } = metric
        <span class="hljs-keyword">if</span> (metric.width !== width) {
          dispatch({ type: COLUMN_RESIZING, id, width: metric.width })
        }
      })
    }
  }, [data, context, rowIdAttr])

  <span class="hljs-keyword">const</span> handleResize = useCallback(() =&gt; {</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>If the table resizes, force the scrollers to update</p></div></div><div class="code"><div class="wrapper">    scrollerDispatch({ type: INVALIDATE })
  }, [])
  useResizeObserver(ref, handleResize)

  <span class="hljs-keyword">let</span> stretch = <span class="hljs-literal">false</span>
  <span class="hljs-keyword">if</span> (hasFixedCols) {
    <span class="hljs-keyword">const</span> { scrollableBody } = scrollerState
    <span class="hljs-keyword">if</span> (scrollableBody &amp;&amp; scrollableBody.isConnected) {
      <span class="hljs-keyword">const</span> section = scrollableBody.closest(<span class="hljs-string">'.rrt-section'</span>)
      <span class="hljs-keyword">const</span> sectionWidth = section.getBoundingClientRect().width
      <span class="hljs-keyword">const</span> bodyWidth = cols.reduce((acc, { width = <span class="hljs-number">250</span> }) =&gt; acc + width, <span class="hljs-number">0</span>)</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>Stretch the columns in the scrollable section if the columns do
not occupy the horizontal space of the section fully</p></div></div><div class="code"><div class="wrapper">      stretch = bodyWidth &lt;= sectionWidth
    }
  }
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span>
      <span class="hljs-attribute">className</span>=<span class="hljs-value">'rrt-data'</span>
      <span class="hljs-attribute">ref</span>=<span class="hljs-value">{ref}</span>
      <span class="hljs-attribute">onMouseDown</span>=<span class="hljs-value">{handleRange}</span>
      <span class="hljs-attribute">onWheel</span>=<span class="hljs-value">{handleWheel}</span>
    &gt;</span>
      {hasFixedCols ? (
        <span class="hljs-tag">&lt;&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-title">Section</span>
            <span class="hljs-attribute">mode</span>=<span class="hljs-value">{Modes.fixed}</span>
            <span class="hljs-attribute">state</span>=<span class="hljs-value">{state}</span>
            <span class="hljs-attribute">columns</span>=<span class="hljs-value">{fixedCols}</span>
            <span class="hljs-attribute">hasFilters</span>=<span class="hljs-value">{hasFilters}</span>
            <span class="hljs-attribute">colOrder</span>=<span class="hljs-value">{colOrder}</span>
            <span class="hljs-attribute">overflow</span>=<span class="hljs-value">{false}</span>
            <span class="hljs-attribute">range</span>=<span class="hljs-value">{fixedRange}</span>
          /&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-title">Section</span>
            <span class="hljs-attribute">mode</span>=<span class="hljs-value">{Modes.scrollable}</span>
            <span class="hljs-attribute">state</span>=<span class="hljs-value">{state}</span>
            <span class="hljs-attribute">columns</span>=<span class="hljs-value">{cols}</span>
            <span class="hljs-attribute">hasFilters</span>=<span class="hljs-value">{hasFilters}</span>
            <span class="hljs-attribute">colOrder</span>=<span class="hljs-value">{colOrder}</span>
            <span class="hljs-attribute">overflow</span>=<span class="hljs-value">{false}</span>
            <span class="hljs-attribute">range</span>=<span class="hljs-value">{range}</span>
            <span class="hljs-attribute">stretch</span>=<span class="hljs-value">{stretch}</span>
          /&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-title">VScroller</span> <span class="hljs-attribute">state</span>=<span class="hljs-value">{scrollerState}</span> /&gt;</span>
        <span class="hljs-tag">&lt;/&gt;</span>
      )</span> : (
        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">Section</span>
          <span class="hljs-attribute">mode</span>=<span class="hljs-value">{Modes.stretch}</span>
          <span class="hljs-attribute">state</span>=<span class="hljs-value">{state}</span>
          <span class="hljs-attribute">columns</span>=<span class="hljs-value">{cols}</span>
          <span class="hljs-attribute">hasFilters</span>=<span class="hljs-value">{hasFilters}</span>
          <span class="hljs-attribute">colOrder</span>=<span class="hljs-value">{colOrder}</span>
          <span class="hljs-attribute">overflow</span>=<span class="hljs-value">{overflow}</span>
          <span class="hljs-attribute">range</span>=<span class="hljs-value">{range}</span>
        /&gt;</span>
      )</span>}
      {resizerState.resizing ? <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">ResizeBar</span> <span class="hljs-attribute">x</span>=<span class="hljs-value">{resizerState.barX}</span> /&gt;</span> : null}
    <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
  )</span>
}

Data.propTypes = {
  state: TableStateType,
  scrollerState: ScrollerStateType,
  resizerState: ResizerStateType
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> areEqual = (prev, next) =&gt; {
  <span class="hljs-keyword">const</span> prevState = prev.state
  <span class="hljs-keyword">const</span> nextState = next.state
  <span class="hljs-keyword">const</span> areEqual =
    prevState.columns === nextState.columns &amp;&amp;
    prevState.data === nextState.data &amp;&amp;
    prevState.selectedIds === nextState.selectedIds &amp;&amp;
    prevState.cellRange === nextState.cellRange &amp;&amp;
    prev.scrollerState === next.scrollerState &amp;&amp;
    prev.resizerState === next.resizerState</div></div></div><div class="segment"><div class="comments "><div class="wrapper"><p>if (!areEqual) {
  console.log(&#39;!Data.areEqual&#39;)
} </p></div></div><div class="code"><div class="wrapper">  <span class="hljs-keyword">return</span> areEqual
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> React.memo(Data, areEqual)</div></div></div></div></body></html>